# Copilot Instructions

- **Stack & layout:** React 19 + Vite + TypeScript SPA. Tailwind utility classes (slate dark theme) and Lucide icons. Entry flow and view switching live in [App.tsx](App.tsx); views are lazy-loaded from [components/views](components/views) to keep the first paint small.
- **State model:** Zustand per domain under [stores](stores). Each store exposes `_hydrateFromFirestore()` and `_reset()` and many selectors under [stores/selectors](stores/selectors) to avoid repetitive derived logic.
- **Firestore-first sync:** All writes go through the debounced `writeToFirestore` (300ms) in [stores/firestoreSync.ts](stores/firestoreSync.ts) which cleans undefineds and tracks pending writes for the sync indicator. Reads are live `onSnapshot` subscriptions set up in [App.tsx](App.tsx) for ~16 store documents under `users/{uid}/data/*`. `flushPendingWrites()` runs on unload and before user switches; never bypass this layer when persisting.
- **Auth:** Firebase auth helpers live in [services/firebase.ts](services/firebase.ts) (email/password, Google, anonymous). `useAuth` wraps auth state, caches `p67_last_uid`, and drives the hydrate/subscription lifecycle in [App.tsx](App.tsx). Remember to call `clearAllStores()` (exported from [stores/index.ts](stores/index.ts)) when changing user contexts to avoid cross-user leakage.
- **Env required:** `.env.local` with `VITE_FIREBASE_API_KEY`, `VITE_FIREBASE_AUTH_DOMAIN`, `VITE_FIREBASE_PROJECT_ID`, `VITE_FIREBASE_STORAGE_BUCKET`, `VITE_FIREBASE_MESSAGING_SENDER_ID`, `VITE_FIREBASE_APP_ID`, `VITE_FIREBASE_MEASUREMENT_ID`, plus `VITE_GEMINI_API_KEY` (see README Gemini section). Missing vars throw on startup.
- **CSP note:** `index.html` has a strict `connect-src`; add new hosts there if Gemini or other APIs move.
- **Domain slices:**
  - Work, Habits, Reading, Skills, Links, Sunday, Journal, Rest, Prompts, Review, Water, Streak, Timer, Games, Weekly Agenda each live in their own store file (see [stores](stores)) with matching views under [components/views](components/views).
  - Shared UI (cards, dropdowns, loading, streak badge, sync status) under [components/shared](components/shared).
- **Data migrations:** Legacy localStorage -> Zustand migrations run via `setupDataMigration` and `setupFirestoreMigration` hooks in [App.tsx](App.tsx); keep them enabled when touching store shapes.
- **Design system:** Theme class applied to `body` (`theme-default` or `theme-amoled`). Colors follow slate surfaces with cyan/orange/purple accents (see README Design System). Recharts handles charts; @dnd-kit powers drag/drop ordering.
- **Build/test workflow:** `npm run dev` (Vite), `npm run build`, `npm run preview`, `npm run test` (Vitest + JSDOM + Testing Library). Tests bootstrap via [tests/setup.ts](tests/setup.ts).
- **Patterns for new work:**
  - Prefer selectors from [stores/selectors](stores/selectors) with `useShallow` rather than ad-hoc derived state inside components.
  - When adding persisted state, wire `_hydrateFromFirestore`, `_reset`, and a debounced `_syncToFirestore` call that funnels through `writeToFirestore` with a unique `collectionKey`.
  - Keep new heavy views lazy via `React.lazy` and gate rendering on `isDataReady` similar to [App.tsx](App.tsx).
  - Surface long-running writes via the sync indicator (pending count subscription in [stores/firestoreSync.ts](stores/firestoreSync.ts)).
- **Routing/state:** No react-router; navigation is store-driven (`activeView` in UI store). Keep new navigation actions consistent with the `ViewState` enum in [types.ts](types.ts).
- **Data formats:** Type definitions and enums live in [types.ts](types.ts); reuse them when extending stores or view props to stay aligned with existing serialization.
- **Common pitfalls:**
  - Firestore rejects `undefined`; rely on `removeUndefined` path already used in `writeToFirestore` and avoid optional fields that stay `undefined` in store snapshots.
  - Subscription order matters: `App.tsx` waits for all store hydrations before showing the UI; avoid introducing new subscriptions without updating the hydration counter.
  - If adding new external calls, ensure CSP and CORS are updated and keep them behind feature flags in config store where possible.
- **AI tools:** The project already optimizes bundle size and realtime sync; autogenerated code should respect lazy loading, debounced writes, and the clearAllStores + hydration lifecycle to prevent regression of offline/online behavior.

If any section is unclear or missing context you need, tell me what to expand or adjust and I will update this file.
